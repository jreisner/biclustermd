#' Bicluster data (old)
#'
#' @param data Dataset to bicluster. Must to be a data matrix with only numbers and missing values in the data set. It should have row names and column names.
#' @param P0 Initial matrix for column prototypes, maybe generated by `partition_gen`.
#' @param Q0 Initial matrix for row prototypes, maybe generated by `partition_gen`.
#' @param miss_val Value or function to put in empty cells of the prototype matrix.
#' @param col_min_num Minimum column prototype size in order to be eligible to be chosen when filling an empty row prototype.
#' @param row_min_num Minimum row prototype size in order to be eligible to be chosen when filling an empty row prototype. Default is 10.
#' @param col_num_to_move Number of columns to remove from the sampled prototype to put in the empty column prototype.
#' @param row_num_to_move Number of rows to remove from the sampled prototype to put in the empty row prototype. Default is 5.
#' @param max.iter Maximum number of iterations to let the algorithm run for.
#' @param verbose Logical. If TRUE, will report progress.
#' @export
#' @importFrom phyclust RRand
#' @return A list containing final matrices for column and row prototypes, the SSE for each iteration, the Rand Indices for row and column prototypes, the number of iterations the algorithm ran for, and the final prototype matrix.

old_bicluster <- function(data, P0, Q0, miss_val, col_min_num = 5, row_min_num = 10,
                      col_num_to_move = 5, row_num_to_move = 5, max.iter = 100,
                      verbose = TRUE) {
  stop("This algorithm is outdated. Please use bicluster.")
  
  data <- as.matrix(data)
  P <- P0
  Q <- Q0
  
  m_d <- nrow(data)
  n_d <- ncol(data)
  
  rep_Q <- ceiling(m_d / n_d)
  rep_P <- ceiling(n_d / m_d)
  
  result_list <- vector("list", 6)
  names(result_list) <- c("P", "Q", "sumSSE", "RIs", "iteration", "A")
  
  sumSSE <- matrix(nrow = max.iter, ncol = 1)
  RIs <- matrix(nrow = max.iter, ncol = 2)
  A <- matrix(nrow = ncol(Q), ncol = ncol(P))
  
  min_sse_list <- vector("list", 6)
  names(min_sse_list) <- c("P", "Q", "sumSSE", "RIs", "iteration", "A")
  
  s <- 0
  
  n_p <- ncol(P)
  n_q <- ncol(Q)
  
  A <- matrix(nrow = n_q, ncol = n_p)
  distq <- matrix(nrow = m_d, ncol = n_q)
  distp <- matrix(nrow = n_d, ncol = n_p)
  p1 <- numeric(n_d)
  q1 <- numeric(m_d)
  
  while(s < max.iter) {
    if(verbose) {
      if(s %% 10 == 0) {
        cat("Iteration ", s, "\n")
      }
    }
    
    P.old <- P
    Q.old <- Q
    
    for(k in 1:rep_Q) {
      for (j in 1:n_q){
        q_ind <- which(Q[, j] == 1)
        
        for (i in 1:n_p){
          p_ind <- which(P[, i] == 1)
          
          x_ij.prime <- data[q_ind, p_ind]
          
          A[j, i] <- sum(x_ij.prime, na.rm = TRUE) /
            (length(x_ij.prime) - sum(is.na(x_ij.prime)))
          
          if(is.na(A[j, i])) {
            condition_call <- substitute(miss_val)
            A[j, i] <- eval(condition_call)
          }
        }
      }
      
      P.count <- colSums(P, na.rm = TRUE)
      
      for (i in 1:m_d) {
        for (j in 1:n_q) {
          A_vec <- rep(A[j, ], P.count)
          
          distq[i, j] <- sum((A_vec - data[i, ]) ^ 2, na.rm = TRUE)
        }
      }
      
      q1 <- unlist(lapply(1:m_d, function(x) which.min(distq[x,])), use.names = FALSE)
      
      Q <- partition_gen_by_p(m_d, n_q, q1)
      
      Q <- random_assign_unassigned_fill_empties_Q(data, Q, row_min_num, row_num_to_move)
    }
    
    for(k in 1:rep_P) {
      for (j in 1:n_q) {
        q_ind <- which(Q[, j] == 1)
        for (i in 1:n_p) {
          p_ind <- which(P[, i] == 1)
          
          x_ij.prime <- data[q_ind, p_ind]
          
          A[j, i] <- sum(x_ij.prime, na.rm = TRUE) /
            (length(x_ij.prime) - sum(is.na(x_ij.prime)))
          
          if(is.na(A[j, i])) {
            condition_call <- substitute(miss_val)
            A[j, i] <- eval(condition_call)
          }
        }
      }
      
      Q.count <- colSums(Q, na.rm = TRUE)
      
      for(i in 1:n_d) {
        for(j in 1:n_p) {
          
          A_vec <- rep(A[, j], Q.count)
          
          distp[i, j] <- sum((A_vec - data[, i]) ^ 2, na.rm = TRUE)
          
        }
      }
      
      p1 <- unlist(lapply(1:n_d, function(x) which.min(distp[x,])), use.names = FALSE)
      
      P <- partition_gen_by_p(n_d, n_p, p1)
      
      P <- random_assign_unassigned_fill_empties_P(data, P, col_min_num, col_num_to_move)
    }
    
    s <- s + 1
    
    sumSSE[s, 1] <- cluster_iteration_sum_sse(data, P, Q)
    
    P.old_vec <- part_matrix_to_vector(P.old) + 1
    P.new_vec <- part_matrix_to_vector(P) + 1
    Q.old_vec <- part_matrix_to_vector(Q.old) + 1
    Q.new_vec <- part_matrix_to_vector(Q) + 1
    
    PRI <- RRand(P.old_vec, P.new_vec)[[1]]
    QRI <- RRand(Q.old_vec, Q.new_vec)[[1]]
    
    RIs[s, 1] <- PRI
    RIs[s, 2] <- QRI
    
    if((PRI == 1) && (QRI == 1)) {
      result_list$P <- P
      result_list$Q <- Q
      result_list$sumSSE <- sumSSE
      result_list$RIs <- RIs
      result_list$iteration <- s
      result_list$A <- A
      
      if(which.min(result_list$sumSSE) == s) {
        min_sse_list$P <- P
        min_sse_list$Q <- Q
        min_sse_list$sumSSE <- sumSSE
        min_sse_list$RIs <- RIs
        min_sse_list$iteration <- s
        min_sse_list$A <- A
      }
      
      return(list(final_iter = result_list, min_sse_iter = min_sse_list))
      break
    }
    
    
    if(which.min(sumSSE) == s) {
      min_sse_list$P <- P
      min_sse_list$Q <- Q
      min_sse_list$sumSSE <- sumSSE[1:s,]
      min_sse_list$RIs <- RIs[1:s,]
      min_sse_list$iteration <- s
      min_sse_list$A <- A
    }
    
    
  }
  
  result_list$P <- P
  result_list$Q <- Q
  result_list$sumSSE <- sumSSE
  result_list$RIs <- RIs
  result_list$iteration <- s
  result_list$A <- A
  
  
  return(list(final_iter = result_list, min_sse_iter = min_sse_list))
  
}