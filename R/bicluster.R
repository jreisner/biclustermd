#' Bicluster data
#'
#' @param data Dataset to bicluster. Must to be a data matrix with only numbers and missing values in the data set. It should have row names and column names.
#' @param P0 Initial matrix for column prototypes, maybe generated by `partition_gen`.
#' @param Q0 Initial matrix for row prototypes, maybe generated by `partition_gen`.
#' @param miss_val Value or function to put in empty cells of the prototype matrix.
#'     If a value, a random normal variable with sd = 1 is used each iteration.
#' @param col_min_num Minimum column prototype size in order to be eligible to be chosen when filling an empty row prototype. Default is 5.
#' @param row_min_num Minimum row prototype size in order to be eligible to be chosen when filling an empty row prototype. Default is 5.
#' @param col_num_to_move Number of columns to remove from the sampled prototype to put in the empty column prototype. Default is 1.
#' @param row_num_to_move Number of rows to remove from the sampled prototype to put in the empty row prototype. Default is 1.
#' @param row_shuffles Number of times to shuffle rows in each iteration. Default is 1.
#' @param col_shuffles Number of times to shuffle columns in each iteration. Default is 1.
#' @param max.iter Maximum number of iterations to let the algorithm run for.
#' @param verbose Logical. If TRUE, will report progress.
#' @export
#' @importFrom phyclust RRand
#' @importFrom stats rnorm
#' @return A list containing final matrices for column and
#'     row partitions, the SSE for each iteration, the Rand Indices for row and column
#'     prototypes, the number of iterations the algorithm ran for, and the final prototype matrix.
#' @examples
#' dat <- kronecker(matrix(1:6, nrow = 2, ncol = 3), matrix(5, nrow = 3, ncol = 4))
#' dat[sample(1:72, 36)] <- NA
#' dat <- dat[sample(1:nrow(dat), nrow(dat)), sample(1:ncol(dat), ncol(dat))]
#' P01 <- partition_gen(12, 3)
#' Q01 <- partition_gen(6, 2)
#'
#' bc <- bicluster(dat, P01, Q01, miss_val = 18.61111,
#'                 col_min_num = 2, row_min_num = 2,
#'                 col_num_to_move = 1, row_num_to_move = 1,
#'                 max.iter = 10)
#' bc
#' gg_sse(bc)
#' gg_bicluster(bc, dat, transform_colors = FALSE)


bicluster <- function(data, P0, Q0, miss_val,
                      row_min_num = 5, col_min_num = 5,
                      row_num_to_move = 1, col_num_to_move = 1,
                      row_shuffles = 1, col_shuffles = 1,
                      max.iter = 100, verbose = TRUE) {

  data <- as.matrix(data)
  P <- P0
  Q <- Q0

  m_d <- nrow(data)
  n_d <- ncol(data)

  result_list <- vector("list", 6)
  names(result_list) <- c("P", "Q", "SSE", "RIs", "iteration", "A")

  SSE <- matrix(nrow = max.iter, ncol = 1)
  RIs <- matrix(nrow = max.iter, ncol = 2)
  A <- matrix(nrow = ncol(Q), ncol = ncol(P))
  u.bar <- matrix(0, nrow = m_d, ncol = ncol(P))

  s <- 0

  n_p <- ncol(P)
  n_q <- ncol(Q)

  A <- matrix(nrow = n_q, ncol = n_p)
  distq <- matrix(nrow = m_d, ncol = n_q)
  distp <- matrix(nrow = n_d, ncol = n_p)
  p1 <- numeric(n_d)
  q1 <- numeric(m_d)

  dat2 <- data
  for (i in 1:m_d){
    for (j in 1:n_d){
      if (!is.na(data[i, j])) {
        dat2[i, j] <- 1
      }
    }
  }

  while(s < max.iter) {
    if(verbose) {
      if(s %% 10 == 0) {
        cat("Iteration ", s, "\n")
      }
    }


    P.old <- P
    Q.old <- Q

    dq <- matrix(0, nrow = n_q, ncol = n_p)

    for(k in 1:row_shuffles) {
      for (j in 1:n_q){
        q_ind <- which(Q[, j] == 1)

        for (i in 1:n_p){
          p_ind <- which(P[, i] == 1)

          x_ij.prime <- data[q_ind, p_ind]

          A[j, i] <- sum(x_ij.prime, na.rm = TRUE) /
            (length(x_ij.prime) - sum(is.na(x_ij.prime)))

          if(is.na(A[j, i])) {
            if(is.numeric(miss_val)) {
              A[j, i] <- rnorm(1, miss_val, 1)
            } else {
              condition_call <- substitute(miss_val)
              A[j, i] <- eval(condition_call)
            }
          }
        }
      }

      for(i in 1:m_d) {
        P.count <- apply(dat2[i,] * P, 2, sum, na.rm = T)
        u.bar[i,] <- apply(data[i,] * P, 2, sum, na.rm = T) / P.count
        u.bar[i, which(u.bar[i,] == 0 | is.na(u.bar[i,]))] <- miss_val
        for(j in 1:n_q) {
          dq[j,] <- A[j,] - u.bar[i,]
          distq[i, j] <- sum((dq[j,] ^ 2) * P.count, na.rm = TRUE)
        }
      }

      q1 <- unlist(lapply(1:m_d, function(x) which.min(distq[x,])), use.names = FALSE)

      Q <- partition_gen_by_p(m_d, n_q, q1)

      Q <- random_assign_unassigned_fill_empties_Q(data, Q, row_min_num, row_num_to_move)
    }

    for(k in 1:col_shuffles) {
      for (j in 1:n_q) {
        q_ind <- which(Q[, j] == 1)
        for (i in 1:n_p) {
          p_ind <- which(P[, i] == 1)

          x_ij.prime <- data[q_ind, p_ind]

          A[j, i] <- sum(x_ij.prime, na.rm = TRUE) /
            (length(x_ij.prime) - sum(is.na(x_ij.prime)))

          if(is.na(A[j, i])) {
            if(is.numeric(miss_val)) {
              A[j, i] <- rnorm(1, miss_val, 1)
            } else {
              condition_call <- substitute(miss_val)
              A[j, i] <- eval(condition_call)
            }
          }
        }
      }

      dp <- matrix(0, nrow = n_p, ncol = n_q)
      i.bar <- matrix(0, nrow = n_d, ncol = n_q)
      for (i in 1:n_d){
        Q.count <- apply(dat2[, i] * Q, 2, sum, na.rm = T)
        i.bar[i, ] <- apply(data[, i] * Q, 2, sum, na.rm = T) / Q.count
        i.bar[i, which(i.bar[i, ] == 0 | is.na(i.bar[i, ]))] <- miss_val
        for (j in 1:n_p){
          dp[j,] <- A[, j] - i.bar[i, ]
          distp[i, j] <- sum((dp[j, ] ^ 2) * Q.count)
        }
      }

      p1 <- unlist(lapply(1:n_d, function(x) which.min(distp[x,])), use.names = FALSE)

      P <- partition_gen_by_p(n_d, n_p, p1)

      P <- random_assign_unassigned_fill_empties_P(data, P, col_min_num, col_num_to_move)
    }

    s <- s + 1

    SSE[s, 1] <- cluster_iteration_sum_sse(data, P, Q)

    P.old_vec <- part_matrix_to_vector(P.old) + 1
    P.new_vec <- part_matrix_to_vector(P) + 1
    Q.old_vec <- part_matrix_to_vector(Q.old) + 1
    Q.new_vec <- part_matrix_to_vector(Q) + 1

    PRI <- RRand(P.old_vec, P.new_vec)[[1]]
    QRI <- RRand(Q.old_vec, Q.new_vec)[[1]]

    RIs[s, 1] <- PRI
    RIs[s, 2] <- QRI

    if((PRI == 1) && (QRI == 1)) {
      result_list$P <- P
      result_list$Q <- Q
      result_list$SSE <- SSE
      result_list$RIs <- RIs
      result_list$iteration <- s
      result_list$A <- A

      return(result_list)
      break
    }


  }

  result_list$P <- P
  result_list$Q <- Q
  result_list$SSE <- SSE
  result_list$RIs <- RIs
  result_list$iteration <- s
  result_list$A <- A


  return(result_list)

}



